# Wiredcraft Back-end Developer Test

Make sure you read the whole document carefully and follow the guidelines in it.

### How to run this demo

#### Prerequisites
you need to install the docker and JDK. This project is based on JDK 11.

1. Clone the repo

  ```
  git clone https://github.com/QinshanSun/test-backend.git
  
  ```

2. Run docker

  ```
  docker-compose up -d 
  
  ```

3. Initial the database with script user.sql
4. Run the project
5. Test with rest-api.http file (in this file I don't provide the delete user api case, you can test by yourself)

### Base Requirement

Build a RESTful API that can `get/create/update/delete` user data from a persistence database

### User Model

```
{
  "id": "xxx",                  // user ID 
  "name": "test",               // user name
  "dob": "",                    // date of birth
  "address": "",                // user address
  "description": "",            // user description
  "createdAt": ""               // user created date
}
```

#### Get API
The Get API use **GET** to return user by given user id with business code and message.


**Request:** [GET] localhost:443/users/{userId}

**Response:** 

```
{
    "code": 0,
    "data": {
        "userId": 1,
        "name": "root",
        "dob": "1990-11-09",
        "address": "shanghai",
        "description": "admin users",
        "createdAt": "2022-02-17"
    },
    "message": "Success."
}

```

### Create API
The create API uses **POST** to create user into service.
Currently this user id is generated by mysql automatically. If we take distrubuted system into consideration, we can use other ways to generated user id. And createdAt(date) is also generated by system.

**Request:**  [POST] localhost:443/users

**Request Body:**

```
{
    "name":"admin4",
    "address":"chengdu",
    "dob":"1990-11-09",
    "description":"test data"
}

```

**Response:**


```
{
    "code": 0,
    "data": 1,
    "message": "Success."
}

```


### Update API

The update API use **PUT** to update user. It is able to update the properties including: username, address, description and dateofBirth.


**Request:** [PATCH] localhost:443/users?userId=1&userName=root&address=shanghai&dateOfBirth=1990/11/10&description=admin users

**Response:**


```
{
    "code": 0,
    "data": 1,
    "message": "Success."
}

```


### Delete API

The delete API use **DELETE** to delete user by user id.

**Request:** [DELETE] localhost:443/user/{userId}


```
{
    "code": 0,
    "data": 1,
    "message": "Success."
}

```





### Tech stack

- Java Framework: Spring boot and mybatis
- DB: MySQL and Redis 

### Advanced requirements


- Provide a complete user auth (authentication/authorization/etc.) strategy, such as OAuth. This should provide a way to
  allow end users to securely login, autenticate requests and only access their own information.
  
  
Use OAuth2 to implement this kind of requirement.

***Authentication***
Usually we would implement an auth-service to handle authentication request. There are several ways to provide token to user such as 'authorization\_code','password','refresh\_token'.

***Authorization***: 

we can add the annotation belong to spring-security on the method to make sure autenticate requests and only access their own information :

```

@PreAuthorize("principal.username.equals(#userId)")

```

Since i don't have enough time to impment this function, just provide solution here.	

	
  
- Provide a complete logging (when/how/etc.) strategy.



Use AOP to implment this kind of requirement. In the codebase, i provide the class 'LogAspectImpl' as Aspect to log the Requst Parameters/Request Name/Request Result when the name of the method in UserController starts with 'update'



- Imagine we have a new requirement right now that the user instances need to link to each other, i.e., a list of "
  followers/following" or "friends". Can you find out how you would design the model structure and what API you would
  build for querying or modifying it?
  This part of requirement uses Redis. I put followers' id and followings' id into two set and store in Redis for login user.
  
  
  ### Get Followers
  
  Get followers for user by user id. 
  
**Request:**  [GET] localhost:443/users/2/followers

**Response:**  

```
{
    "code": 0,
    "data": [
        {
            "userId": 1,
            "name": "root",
            "dob": "1990-11-09",
            "address": "shanghai",
            "description": "admin users",
            "createdAt": "2022-02-17"
        }
    ],
    "message": "Success."
}

```

### Get Following

Get following for user by user id.

**Request:**  [GET] localhost:443/users/2/following

**Response:**  

```
{
    "code": 0,
    "data": [
        {
            "userId": 1,
            "name": "root",
            "dob": "1990-11-09",
            "address": "shanghai",
            "description": "admin users",
            "createdAt": "2022-02-17"
        }
    ],
    "message": "Success."
}

```

### Follow User

Follow user: since i don't implement login part requirement so i pass the loginUserId as request param.

In this action, we will put values into two set with name: #{UserId}\_FOLLOWING AND #{UserId}\_FOLLOWER.

**Request:**  [POST] localhost:443/users/6/follower?loginUserId=1


**Response:**

```
{
    "code": 0,
    "data": null,
    "message": "Success."
}

```

### Unfollow User

Unfollow user: remove the related values from two sets: #{UserId}\_FOLLOWING AND #{UserId}\_FOLLOWER.


**Request:** [DELETE] localhost:443/users/1/follower?loginUserId=2

**Response:**

```
{
    "code": 0,
    "data": null,
    "message": "Success."
}

```

###Get Friends By User

Friend Definition: if A follow B and B follow A, then we can say A and B are friends.

Implmentation Logic: Get the intersection of two sets: #{UserId}\_FOLLOWING AND #{UserId}\_FOLLOWER.

For example: A\_FOLLOWING contains: {B, C, D} A\_FOLLOWER contains {B,C,E,F}, then we can say {B, C} is A's friends set.


**Request:** [GET] localhost:443/users/2/friends

**Response:**

```
{
    "code": 0,
    "data": [
        {
            "userId": 1,
            "name": "root",
            "dateOfBirth": "1990-11-09",
            "address": "shanghai",
            "description": "admin user",
            "createdAt": null,
            "geoPosition": null
        }
    ],
    "message": "Success."
}

```

  
  
- Related to the requirement above, suppose the address of user now includes a geographic coordinate(i.e., latitude and
  longitude), can you build an API that,
  - given a user name
  - return the nearby friends

  
 Use Redis to store GEOPOSTION. For this requirement, we provide two apis: Update User's GEO and Find nearby friends.

### Update User's GEO

**Request:** [PUT] localhost:443/users/{username}/geo

**Request Body:**

```
{
    "x": "23.3012",
    "y": "12.2342"   
}

```

**Request Response**

```
{
    "code": 1,
    "data": 0,
    "message": "Success."
}

```

### Get Nearby Friends

Implememtation Logic:

**Request:** [GET] localhost:443/users/root/nearby


**Request Response**

```
{
    "code": 0,
    "data": [
        {
            "userName": "admin",
            "distance": 0.1306,
            "latitude": 23.301199972629547,
            "longitude": 12.234200477478133
        },
        {
            "userName": "admin2",
            "distance": 4.9565,
            "latitude": 23.2544007897377,
            "longitude": 12.234200477478133
        }
    ],
    "message": "Success."
}

```


### Need to Improve
1. UT coverage (don't have enough time)
2. Validation for Requests
3. Precision of GEO changes after storing into Redis (need to fix)
