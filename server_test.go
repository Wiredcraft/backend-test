//Testing functions for the server. It tests the following API methods:

//GET 		/user/
//GET 		/user/<id>
//POST 		/user/
//DELETE 	/user/<id>
//PUT 		/user/ <id>

//This code honestly contains *a lot* of boilerplate due to the fact that we can't create a user with
//a specific ID and push it to the server. This means that every time we add a user and want to test
//if that user was actually added, we have to retrieve all users and filter out our user based on the
//other attributes. Since the attributes don't have constraints of being unique, there is a chance
//(very slim) that the test randomly fails.
//I still prefer this approach much better rather than clearing the database for each testing method
//because this way the scope of testing is much wider.

package main

import (
	"encoding/json"
	"errors"
	"log"
	"math/rand"
	"net/http"
	"net/http/httptest"
	"net/url"
	"reflect"
	"strconv"
	"strings"
	"testing"
)

//Global variables that are used when connecting to the server
var (
	ts         *httptest.Server
	userAPIUrl string
)

//-------------------------------------------------------------------------------------------------
//Setup & teardown of the testing server
//-------------------------------------------------------------------------------------------------

//Sets up an in memory database for testing. Starts a httptest.NewServer by passing the martini handler
//to that server. Once this is setup, we are free to query the REST API.
func init() {
	m := SetupMartini()
	handler, err := CreateDb(":memory:")
	if err != nil {
		log.Fatalln(err.Error())
	}
	m.Use(handler)

	ts = httptest.NewServer(m)
	userAPIUrl = ts.URL + "/user/"
}

//Tears the testing server down
func tearDown() {
	ts.Close()
}

//-------------------------------------------------------------------------------------------------
//Reusable test helper functions
//-------------------------------------------------------------------------------------------------

//It's basically used here to fetch one
//unique user that's usually added to the database at the beginning of a test function. We then test
//if the user we added is in the list of all users and so on...
//Comment this
func predicateForTests(usr User) UserPredicate {
	return func(u User) bool {
		if usr.Name == u.Name && usr.Dob == u.Dob &&
			usr.Address == u.Address && usr.Description == u.Description {
			return true
		}
		return false
	}
}

//Generates a random string of 10 characters. Used to populate random user fields
func randStr() string {
	alphabet := "abcdefghijklmnopqrstuvwqyx"
	s := ""
	for i := 0; i < 10; i++ {
		s += string(alphabet[rand.Intn(len(alphabet))])
	}
	return s
}

//Generates a random user. The `ID` and `CreatedAt` attributes are generated by the server
func generateRandomUser() User {
	u := User{}
	u.Name = randStr()
	u.Address = randStr()
	u.Description = randStr()
	u.Dob = randStr()
	return u
}

//Convenience method for doing a http request, adding headers, data and checking the response status.
func requestWrapper(urlStr, method string, data map[string]string, expectedStatusCode int) (*http.Response, error) {
	log.Println("Requesting", urlStr, "Using", method)

	dataReader := strings.NewReader("")
	if data != nil {
		params := url.Values{}
		for k, v := range data {
			params.Add(k, v)
		}
		dataReader = strings.NewReader(params.Encode())
	}
	req, err := http.NewRequest(method, urlStr, dataReader)
	if err != nil {
		return &http.Response{}, err
	}
	//All of the routes require authorization. @Todo: Make more fluid
	req.Header.Add("Authorization", APIKey)
	req.Header.Add("Content-Type", "application/x-www-form-urlencoded")

	res, err := http.DefaultClient.Do(req)
	if err != nil {
		return &http.Response{}, err
	}

	if res.StatusCode != expectedStatusCode {
		err = errors.New("Expected status: " + strconv.Itoa(expectedStatusCode) + " got " + res.Status)
		return &http.Response{}, err
	}

	return res, nil
}

//Reusable function to add a user to the database
func addUser(u User) error {
	params := make(map[string]string)
	params["name"] = u.Name
	params["dob"] = u.Dob
	params["address"] = u.Address
	params["description"] = u.Description

	res, err := requestWrapper(userAPIUrl, "POST", params, 200)
	if err != nil {
		return err
	}
	defer res.Body.Close()

	return nil
}

//Reusable function to add a user to the database
func deleteUser(id int) error {
	userUrl := userAPIUrl + strconv.Itoa(id)
	res, err := requestWrapper(userUrl, "DELETE", nil, 200)
	if err != nil {
		return err
	}
	defer res.Body.Close()
	return nil
}

//Reusable function to get a single user from the database
func getUser(id int) (User, error) {
	userUrl := userAPIUrl + strconv.Itoa(id)
	res, err := requestWrapper(userUrl, "GET", nil, 200)
	if err != nil {
		return User{}, err
	}
	defer res.Body.Close()

	u := User{}
	err = json.NewDecoder(res.Body).Decode(&u)
	if err != nil {
		return User{}, err
	}
	return u, nil
}

//Gets the list of all users
func getAllUsers() ([]User, error) {
	res, err := requestWrapper(userAPIUrl, "GET", nil, 200)
	if err != nil {
		return []User{}, nil
	}
	defer res.Body.Close()

	users := make([]User, 0, 0)
	err = json.NewDecoder(res.Body).Decode(&users)
	if err != nil {
		return []User{}, err
	}

	return users, nil
}

//Finds one user in the datababase that matches the predicate we have passed
//Since we can't generate uuids locally, we have to compare all the other attributes to verify that
//the user locally is the same user that is store in the db. There can only be 1 such user.
func matchLocalAndDbUser(u User) (User, error) {
	dbUsers, err := getAllUsers()
	if err != nil {
		return User{}, err
	}
	filtered := FilterUsers(dbUsers, predicateForTests(u))
	if len(filtered) == 1 {
		return filtered[0], nil
	} else {
		werr := errors.New(`There should be exactly 1 user with these details. Either very strange
				randomization or a serious error`)
		return User{}, werr
	}
}

//-------------------------------------------------------------------------------------------------
//The actual tests
//-------------------------------------------------------------------------------------------------

//Tests POST /user/
//Expects that a user we have added exists in the database
func TestAddUser(t *testing.T) {
	localUser := generateRandomUser()
	err := addUser(localUser)
	if err != nil {
		t.Error(err)
	}

	_, err = matchLocalAndDbUser(localUser)
	if err != nil {
		t.Error(err)
	}
}

//Tests DELETE /user/<id>
//Expects that a user we added and then deleted was removed from the database
func TestDeleteUser(t *testing.T) {
	localUser := generateRandomUser()
	if err := addUser(localUser); err != nil {
		t.Error(err)
	}

	//We need to find the user from the db to get the id.
	foundUser, err := matchLocalAndDbUser(localUser)
	if err != nil {
		t.Error(err)
	}

	if err = deleteUser(foundUser.ID); err != nil {
		t.Error(err)
	}

	//Get all users to ensure that the deleted user is not among them
	allUsers, err := getAllUsers()
	if err != nil {
		t.Error(err)
	}

	if len(FilterUsers(allUsers, predicateForTests(localUser))) > 0 {
		t.Error("Failed to delete the user...")
	}
}

//Tests PUT /user/<id>
//Expects that the user we have added and updated actually has updated fields
func TestUpdateUser(t *testing.T) {
	localUser := generateRandomUser()
	if err := addUser(localUser); err != nil {
		t.Error(err)
	}

	//We need to find the user from the db to get the id.
	foundUser, err := matchLocalAndDbUser(localUser)
	if err != nil {
		t.Error(err)
	}

	updatedParams := make(map[string]string)
	updatedParams["name"] = "updated"
	updatedParams["dob"] = "updated"
	updatedParams["address"] = "updated"
	updatedParams["description"] = "updated"

	userUrl := userAPIUrl + strconv.Itoa(foundUser.ID)
	res, err := requestWrapper(userUrl, "PUT", updatedParams, 200)
	if err != nil {
		t.Error(err)
	}
	defer res.Body.Close()

	var updatedUser User
	if err = json.NewDecoder(res.Body).Decode(&updatedUser); err != nil {
		t.Error(err)
	}

	if updatedUser.Name != "updated" &&
		updatedUser.Address != "updated" &&
		updatedUser.Dob != "updated" &&
		updatedUser.Description != "updated" {
		t.Error("User was never updated...", updatedUser)
	}
}

//Tests GET /user/<id>
//Expects to retrieve one user that was added in the test case as json
//We're already testing for this everywhere else, but for sake of consistency...
func TestGetUser(t *testing.T) {
	u := generateRandomUser()
	if err := addUser(u); err != nil {
		t.Error(err)
	}

	users, err := getAllUsers()
	if err != nil {
		t.Error(err)
	}

	filtered := FilterUsers(users, predicateForTests(u))
	if len(filtered) != 1 {
		t.Error("Couldn't find exactly one user that was added to the db")
	}

	foundUser := filtered[0]

	returned, err := getUser(foundUser.ID)
	if err != nil {
		t.Error(err)
	}

	if !reflect.DeepEqual(foundUser, returned) {
		t.Error("The found user did not equal the one we filtered out...")
	}
}

//Tests GET /user/
//Expects a 200 response and a list of all the users we just added as json
//It first clears the database, then adds 10 users, then requests all the users in the database and
//compares if those users attributes are the same as the ones we pushed locally
func TestGetAllUsers(t *testing.T) {
	users, err := getAllUsers()
	if err != nil {
		t.Error(err)
	}

	//First, clear the database
	for _, u := range users {
		if err := deleteUser(u.ID); err != nil {
			t.Error(err)
		}
	}

	users = users[:0]
	for i := 0; i < 10; i++ {
		u := generateRandomUser()
		if err = addUser(u); err != nil {
			t.Error(err)
		}
		users = append(users, u)
	}

	responseUsers, err := getAllUsers()
	if err != nil {
		t.Error(err)
	}

	//Compare local users and users in db
	for idx, u := range responseUsers {
		//Hack, the locally generated users will never have an ID or CreatedAt. So we have to compensate
		users[idx].ID = u.ID
		users[idx].CreatedAt = u.CreatedAt

		if !reflect.DeepEqual(u, users[idx]) {
			log.Println(u.ID, users[idx].ID)
			t.Error("The locally generated users and the users from the API are not the same")
		}
	}

}
